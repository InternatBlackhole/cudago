package main

import (
	"errors"
	"fmt"
	"os"
	"strings"
	"text/template"
)

const (
	prodTemplate = `// Code generated by cudago. Edit at your own risk.
package {{.Package}} //the package where it is placed

import (
    "sync"
    "github.com/InternatBlackhole/cudago/cuda"
)

var LoadedLib *cuda.Library = nil

{{range .Funcs}}{{ $argsName := .Name | lower }}
type {{$argsName}}Args struct {
    //sync.Mutex
{{range $argName, $argType := .GoArgs }}    {{$argName}} {{$argType}}
{{end}}
}{{end}}

/*var ({{range .Funcs}}{{ $argsName := .Name | lower }}
    {{$argsName}}Args = {{$argsName}}Args{}
{{end}}
)*/

var kernCache = make(map[string]*CudaKernel) //cache for the kernels: RawName -> CudaKernel

func InitLibrary() error {
	if LoadedLib == nil {
		//load the kernel from PTX/cubin code
		LoadedLib, err := cuda.LoadLibraryData(ptxCode, nil, nil)
		if err != nil {
			return nil, err
		}
	}
	return nil
}

func CloseLibrary() error {
	if LoadedLib == nil {
		return errors.New("library not initialized")
	}
	return LoadedLib.Unload()
}

func getKernel(kernelName string) (*CudaKernel, error) {
	if loadedLib == nil {
		return nil, errors.New("library not initialized")
	}
	kern := kernCache[kernelName]
	if kern == nil {
		kern, err := LoadedLib.GetKernel(kernelName)
		if err != nil {
			return nil, err
		}
		kernCache[kernelName] = kern
	}
	return kern, nil
}

{{range .Funcs}}
{{ $argsName := .Name | lower }}
func {{.Name}}(grid: cuda.Dim3, block: cuda.Dim3, {{argPrint .GoArgs ", "}}) error {
	kern, err := getKernel("{{.RawName}}")
	if err != nil {
		return err
	}
	/*params := {{$argsName}}Args{
	{{range $argName, $argType := .GoArgs}}    {{$argName}}: {{$argName}}
	{{end}}
	}*/
	return kern.Launch(grid, block, {{passArgsPtrs .GoArgs}})
}

//One with stream and shared mem should be here, or a separate function for each
{{end}}

const ptxCode = "{{.PTXCode}}"
`
)

var templateFunctions = template.FuncMap{
	"upper":    strings.ToUpper,
	"lower":    strings.ToLower,
	"argPrint": argPrint,
	"passArgs": passArgs,
	"passArgsPtrs": func(args map[string]string) string {
		return passArgs(args, "unsafe.Pointer(&%s)")
	},
}

func createFileFromDevTemplate(kernel *TemplateArgs, outFile *os.File) error {
	if outFile == nil {
		return errors.New("file is nil")
	}

	tmpl := template.New("devTemplate")
	tmpl = tmpl.Funcs(templateFunctions)

	tmpl, err := tmpl.Parse(prodTemplate)
	if err != nil {
		return err
	}

	err = tmpl.Execute(outFile, kernel)
	if err != nil {
		return err
	}

	return nil
}

func argPrint(args map[string]string, sep string) string {
	var builder strings.Builder
	var i int = 0
	for name, gotype := range args {
		fmt.Fprintf(&builder, "%s %s", name, gotype)
		if i != len(args)-1 {
			builder.WriteString(sep)
		}
		i++
	}
	return builder.String()
}

func passArgs(args map[string]string, pattern string) string {
	var builder strings.Builder
	var i int = 0
	for name := range args {
		//fmt.Fprintf(&builder, pattern, name)
		builder.WriteString(passArg(name, pattern))
		if i != len(args)-1 {
			builder.WriteString(", ")
		}
		i++
	}
	return builder.String()
}

func passArg(name, pattern string) string {
	return fmt.Sprintf(pattern, name)
}
