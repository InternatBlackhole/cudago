package main

import (
	"errors"
	"fmt"
	"os"
	"strings"
	"text/template"
	"unicode"
)

const (
	utilityFile = `// Code generated by cudago. Edit at your own risk.
package {{.Package}}

import (
    "github.com/InternatBlackhole/cudago/cuda"
	"errors"
)

var (
	errLibNotInit = errors.New("library not initialized")
)

var LoadedLib *cuda.Library = nil

var kernCache = make(map[string]*cuda.Kernel) //cache for the kernels: RawName -> CudaKernel

func InitLibrary() error {
	if LoadedLib == nil {
		//load the kernel from PTX/cubin code
		var err error
		LoadedLib, err = cuda.LoadLibraryData([]byte(ptxCode), nil, nil)
		return err
	}
	return nil
}

func CloseLibrary() error {
	if LoadedLib == nil {
		return errLibNotInit
	}
	return LoadedLib.Unload()
}

func getKernel(kernelName string) (*cuda.Kernel, error) {
	if LoadedLib == nil {
		return nil, errLibNotInit
	}
	kern := kernCache[kernelName]
	if kern == nil {
		kern, err := LoadedLib.GetKernel(kernelName)
		if err != nil {
			return nil, err
		}
		kernCache[kernelName] = kern
	}
	return kern, nil
}
`
	prodTemplate = `// Code generated by cudago. Edit at your own risk.
package {{.Package}} //the package where it is placed

import (
    //"sync"
    "github.com/InternatBlackhole/cudago/cuda"
	"unsafe"
	"errors"
)
{{$errNotInitLib := namespaced "errNotInitLib" .FileName}}
var (
	{{$errNotInitLib}} = errors.New("library {{.FileName}} not initialized")
)
{{$lib := namespaced "LoadedLib" .FileName}}
var {{$lib}} *cuda.Library = nil
{{$kernCache := namespaced "kernCache" .FileName}}
var {{$kernCache}} = make(map[string]*cuda.Kernel) //cache for the kernels: RawName -> CudaKernel
{{$init := namespaced "InitLibrary" .FileName}}
func {{$init}}() error {
	if {{$lib}} == nil {
		//load the kernel from PTX/cubin code
		var err error
		{{$lib}}, err = cuda.LoadLibraryData([]byte({{.FileName}}_ptxCode), nil, nil)
		return err
	}
	return nil
}
{{$close := namespaced "CloseLibrary" .FileName}}
func {{$close}}() error {
	if {{$lib}} == nil {
		return errNotInitLib_{{.FileName}}
	}
	return {{$lib}}.Unload()
}
{{$getKernel := namespaced "getKernel" .FileName}}
func {{$getKernel}}(kernelName string) (*cuda.Kernel, error) {
	if {{$lib}} == nil {
		return nil, {{$errNotInitLib}}
	}
	kern := {{$kernCache}}[kernelName]
	var err error
	if kern == nil {
		kern, err = {{$lib}}.GetKernel(kernelName)
		if err != nil {
			return nil, err
		}
		{{$kernCache}}[kernelName] = kern
	}
	return kern, nil
}

{{range .Funcs}}{{ $argsName := .Name | lower }}
type {{$argsName}}Args struct {
    //sync.Mutex
{{range .GoArgs }}    {{.Name}} {{.Type}}
{{end}}
}{{end}}

/*var ({{range .Funcs}}{{ $argsName := .Name | lower }}
    {{$argsName}}Args = {{$argsName}}Args{}
{{end}}
)*/

{{if ne (len .Constants) 0}}
var (
{{range $name, $type := .Constants}}
	{{$name | title}} = &cuda.WrapAllocation() // c type: {{$type}} __constant__{{end}}
){{else}}{{end}}
{{if ne (len .Variables) 0}}
var (
{{range $name, $type := .Variables}}
	{{$name | title}} = &cuda.WrapAllocation() // c type: {{$type}} __device__{{end}}
){{else}}{{end}}

{{range .Funcs}}
{{ $argsName := .Name | lower }}
func {{.Name}}(grid, block cuda.Dim3, {{argPrint .GoArgs ", "}}) error {
	kern, err := {{$getKernel}}("{{.RawName}}")
	if err != nil {
		return err
	}
	params := {{$argsName}}Args{
	{{range .GoArgs}}    {{.Name}}: {{.Name}},
	{{end}}
	}
	return kern.Launch(grid, block, {{passArgsPtrs .GoArgs "params"}})
}

//One with stream and shared mem should be here, or a separate function for each
{{end}}

const {{.FileName}}_ptxCode = ` + "`{{.PTXCode}}`"
)

var templateFunctions = template.FuncMap{
	"upper":    strings.ToUpper,
	"lower":    strings.ToLower,
	"title":    func(s string) string { return string(unicode.ToUpper(rune(s[0]))) + s[1:] },
	"argPrint": argPrint,
	"passArgs": passArgs,
	"passArgsPtrs": func(args []Arg, from string) string {
		return passArgs(args, fmt.Sprintf("unsafe.Pointer(&%s.%%s)", from))
	},
	"namespaced": func(name, namespace string) string {
		return name + "_" + namespace
	},
}

func createProdFile(kernel *TemplateArgs, outFile *os.File) error {
	if outFile == nil {
		return errors.New("file is nil")
	}

	tmpl := template.New("prodTemplate")
	tmpl = tmpl.Funcs(templateFunctions)

	tmpl, err := tmpl.Parse(prodTemplate)
	if err != nil {
		return err
	}

	err = tmpl.Execute(outFile, kernel)
	if err != nil {
		return err
	}

	return nil
}

func createDevFile(kernel *TemplateArgs, outFile *os.File) error {
	panic("not implemented")
}

func createUtilityFile(kernel *TemplateArgs, outFile *os.File) error {
	if outFile == nil {
		return errors.New("file is nil")
	}

	tmpl := template.New("utilityFile")

	tmpl, err := tmpl.Parse(utilityFile)
	if err != nil {
		return err
	}

	err = tmpl.Execute(outFile, kernel)
	if err != nil {
		return err
	}

	return nil
}

func argPrint(args []Arg, sep string) string {
	var builder strings.Builder
	var i int = 0
	for _, gotype := range args {
		fmt.Fprintf(&builder, "%s %s", gotype.Name, gotype.Type)
		if i != len(args)-1 {
			builder.WriteString(sep)
		}
		i++
	}
	return builder.String()
}

func passArgs(args []Arg, pattern string) string {
	var builder strings.Builder
	var i int = 0
	for _, arg := range args {
		//fmt.Fprintf(&builder, pattern, name)
		builder.WriteString(passArg(arg.Name, pattern))
		if i != len(args)-1 {
			builder.WriteString(", ")
		}
		i++
	}
	return builder.String()
}

func passArg(name, pattern string) string {
	return fmt.Sprintf(pattern, name)
}
