package main

import (
	"errors"
	"fmt"
	"os"
	"strings"
	"text/template"
	"unicode"
)

const (
	utilityFile = `// Code generated by cudago. Edit at your own risk.
package {{.Package}}

import (
    "github.com/InternatBlackhole/cudago/cuda"
	"errors"
)

var (
	errLibNotInit = errors.New("library not initialized")
)

var LoadedLibs = make(map[string]*cuda.Library)

var kernCache = make(map[string]map[string]*cuda.Kernel) //cache for the kernels: RawName -> CudaKernel

func InitLibrary(code []byte, name string) error {
	lib := LoadedLibs[name]
	if lib == nil {
		//load the kernel from PTX/cubin code and init kernel cache
		kernCache[name] = make(map[string]*cuda.Kernel)
		var err error
		lib, err = cuda.LoadLibraryData(code, nil, nil)
		if err != nil {
			return err
		}
		LoadedLibs[name] = lib
	}
	return nil
}

func CloseLibrary(name string) error {
	lib := LoadedLibs[name]
	if lib == nil {
		return errLibNotInit
	}
	delete(LoadedLibs, name)
	delete(kernCache, name)
	return lib.Unload()
}

func getKernel(libName, kernelName string) (*cuda.Kernel, error) {
	var err error
	lib := LoadedLibs[libName]
	if lib == nil {
		return nil, errLibNotInit
	}
	kern := kernCache[libName][kernelName]
	if kern == nil {
		kern, err = lib.GetKernel(kernelName)
		if err != nil {
			return nil, err
		}
		kernCache[libName][kernelName] = kern
	}
	return kern, nil
}
`
	prodTemplate = `// Code generated by cudago. Edit at your own risk.
package {{.Package}}

import (
    "github.com/InternatBlackhole/cudago/cuda"
	"unsafe"
)
{{$key := .FileName}}

const (
	Key{{$key | title}} = "{{$key}}"
)

{{range .Funcs}}{{ $argsName := .Name | lower }}
type {{$argsName}}Args struct {
{{range .GoArgs }}    {{.Name}} {{.Type}}
{{end}}
}{{end}}

/*var ({{range .Funcs}}{{ $argsName := .Name | lower }}
    {{$argsName}}Args = {{$argsName}}Args{}
{{end}}
)*/

{{if ne (len .Constants) 0}}
var (
{{range $name, $type := .Constants}}
	{{$name | title}} = &cuda.WrapAllocation() // c type: {{$type}} __constant__{{end}}
){{else}}{{end}}
{{if ne (len .Variables) 0}}
var (
{{range $name, $type := .Variables}}
	{{$name | title}} = &cuda.WrapAllocation() // c type: {{$type}} __device__{{end}}
){{else}}{{end}}

{{range .Funcs}}
{{template "functionTemplate" .}}
{{end}}

var loaded_{{$key}} = false

func autoloadLib_{{$key}}() error {
	if loaded_{{$key}} {
		return nil
	}
	return InitLibrary([]byte({{.FileName | title}}_ptxCode), "{{$key}}")
}

const {{.FileName | title}}_ptxCode = ` + "`{{.PTXCode}}`"
	functionTemplate = `{{$key := .FileName}}
{{ $argsName := .Name | lower }}
func {{.Name}}(grid, block cuda.Dim3, {{argPrint .GoArgs ", "}}) error {
	err := autoloadLib_{{$key}}()
	if err != nil {
		return err
	}
	kern, err := getKernel("{{$key}}", "{{.RawName}}")
	if err != nil {
		return err
	}
	params := {{$argsName}}Args{
	{{range .GoArgs}}    {{.Name}}: {{.Name}},
	{{end}}
	}
	return kern.Launch(grid, block, {{passArgsPtrs .GoArgs "params"}})
}

func {{.Name}}Ex(grid, block cuda.Dim3, sharedMem uint64, stream *cuda.Stream, {{argPrint .GoArgs ", "}}) error {
	err := autoloadLib_{{$key}}()
	if err != nil {
		return err
	}
	kern, err := getKernel("{{$key}}", "{{.RawName}}")
	if err != nil {
		return err
	}
	params := {{$argsName}}Args{
	{{range .GoArgs}}    {{.Name}}: {{.Name}},
	{{end}}
	}
	return kern.LaunchEx(grid, block, sharedMem, stream, {{passArgsPtrs .GoArgs "params"}})
}
`
	devTemplate = `// Code generated by cudago. Edit at your own risk.
package {{.Package}}


`
)

var templateFunctions = template.FuncMap{
	"upper":    strings.ToUpper,
	"lower":    strings.ToLower,
	"title":    func(s string) string { return string(unicode.ToUpper(rune(s[0]))) + s[1:] },
	"argPrint": argPrint,
	"passArgs": passArgs,
	"passArgsPtrs": func(args []Arg, from string) string {
		return passArgs(args, fmt.Sprintf("unsafe.Pointer(&%s.%%s)", from))
	},
	"namespaced": func(name, namespace string) string {
		return name + "_" + namespace
	},
}

func createProdFile(kernel *TemplateArgs, outFile *os.File) error {
	if outFile == nil {
		return errors.New("file is nil")
	}

	tmpl := template.New("prodTemplate")
	tmpl.Funcs(templateFunctions)

	funcTmpl := tmpl.New("functionTemplate")
	_, err := funcTmpl.Parse(functionTemplate)
	if err != nil {
		return err
	}

	tmpl, err = tmpl.Parse(prodTemplate)
	if err != nil {
		return err
	}

	err = tmpl.Execute(outFile, kernel)
	if err != nil {
		return err
	}

	return nil
}

func createDevFile(kernel *TemplateArgs, outFile *os.File) error {
	panic("not implemented")
}

func createUtilityFile(kernel *TemplateArgs, outFile *os.File) error {
	if outFile == nil {
		return errors.New("file is nil")
	}

	tmpl := template.New("utilityFile")

	tmpl, err := tmpl.Parse(utilityFile)
	if err != nil {
		return err
	}

	err = tmpl.Execute(outFile, kernel)
	if err != nil {
		return err
	}

	return nil
}

func argPrint(args []Arg, sep string) string {
	var builder strings.Builder
	var i int = 0
	for _, gotype := range args {
		fmt.Fprintf(&builder, "%s %s", gotype.Name, gotype.Type)
		if i != len(args)-1 {
			builder.WriteString(sep)
		}
		i++
	}
	return builder.String()
}

func passArgs(args []Arg, pattern string) string {
	var builder strings.Builder
	var i int = 0
	for _, arg := range args {
		//fmt.Fprintf(&builder, pattern, name)
		builder.WriteString(passArg(arg.Name, pattern))
		if i != len(args)-1 {
			builder.WriteString(", ")
		}
		i++
	}
	return builder.String()
}

func passArg(name, pattern string) string {
	return fmt.Sprintf(pattern, name)
}
