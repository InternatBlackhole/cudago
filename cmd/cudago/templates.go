package main

import (
	"fmt"
	"strings"
	"text/template"
	"unicode"
)

type utilityTemplate string
type wrapperTemplates string
type funcTemplate string
type autoloadTemplate string

const (
	utilityFile utilityTemplate = `// Code generated by cudago. Edit at your own risk.
package {{.Package}}

import (
    "github.com/InternatBlackhole/cudago/cuda"
	"github.com/InternatBlackhole/cudago/nvrtc"
	"errors"
	"bufio"
	"os"
	"fmt"
)

var (
	errLibNotInit = errors.New("library not initialized")
)

var LoadedLibs = make(map[string]*cuda.Library)

var kernCache = make(map[string]map[string]*cuda.Kernel) //cache for the kernels: RawName -> CudaKernel

func InitLibrary(code []byte, name string) error {
	lib := LoadedLibs[name]
	if lib == nil {
		//load the kernel from PTX/cubin code and init kernel cache
		kernCache[name] = make(map[string]*cuda.Kernel)
		var err error
		lib, err = cuda.LoadLibraryData(code, nil, nil)
		if err != nil {
			return err
		}
		LoadedLibs[name] = lib
	}
	return nil
}

func CloseLibrary(name string) error {
	lib := LoadedLibs[name]
	if lib == nil {
		return errLibNotInit
	}
	delete(LoadedLibs, name)
	delete(kernCache, name)
	return lib.Unload()
}

func getKernel(libName, kernelName string) (*cuda.Kernel, error) {
	var err error
	lib := LoadedLibs[libName]
	if lib == nil {
		return nil, errLibNotInit
	}
	kern := kernCache[libName][kernelName]
	if kern == nil {
		kern, err = lib.GetKernel(kernelName)
		if err != nil {
			return nil, err
		}
		kernCache[libName][kernelName] = kern
	}
	return kern, nil
}

func compileFile(path string) ([]byte, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()
	stat, err := file.Stat()
	if err != nil {
		return nil, err
	}
	buf := make([]byte, stat.Size())
	reader := bufio.NewReader(file)
	read, err := reader.Read(buf)
	if err != nil {
		return nil, err
	}
	if read != len(buf) {
		return nil, errors.New("could not read the whole file")
	}
	program, err := nvrtc.CreateProgram(string(buf), file.Name(), nil)
	if err != nil {
		return nil, nvrtcErr(err, program)
	}
	defer program.Destroy()
	err = program.Compile([]string{ {{range .Options}} "{{.}}", {{end}} })
	if err != nil {
		return nil, nvrtcErr(err, program)
	}

	ptx, err := program.GetPTX()
	if err != nil {
		return nil,	nvrtcErr(err, program)
	}
	return ptx, nil
}

func nvrtcErr(orig error, program *nvrtc.Program) error {
	log, err := program.GetLog()
	if err != nil {
		return err
	}
	return fmt.Errorf("error \"%s\" log: %s", orig, log)
}
`
	wrapperTemplate wrapperTemplates = `// Code generated by cudago. Edit at your own risk.
package {{.Package}}

import (
    "github.com/InternatBlackhole/cudago/cuda"
	"unsafe"
)
{{$key := .GetKey}}

const (
	Key{{$key | title}} = "{{$key}}"
)

{{range .Funcs}}{{ $argsName := .Name | lower }}
type {{$argsName}}Args struct {
{{range .GoArgs }}    {{.Name}} {{.Type}}
{{end}}
}{{end}}

/*var ({{range .Funcs}}{{ $argsName := .Name | lower }}
    {{$argsName}}Args = {{$argsName}}Args{}
{{end}}
)*/

{{if ne (len .Constants) 0}}
var (
{{range $name, $type := .Constants}}
	{{$name | title}} = &cuda.WrapAllocation() // c type: {{$type}} __constant__{{end}}
){{else}}{{end}}
{{if ne (len .Variables) 0}}
var (
{{range $name, $type := .Variables}}
	{{$name | title}} = &cuda.WrapAllocation() // c type: {{$type}} __device__{{end}}
){{else}}{{end}}

{{range .Funcs}}
{{template "functionTemplate" .}}
{{end}}

var loaded_{{$key}} = false

{{template "autoload" .}}
`
	functionTemplate funcTemplate = `{{$key := .TemplateArgs.GetKey}}
{{ $argsName := .Name | lower }}
func {{.Name}}(grid, block cuda.Dim3, {{argPrint .GoArgs ", "}}) error {
	err := autoloadLib_{{$key}}()
	if err != nil {
		return err
	}
	kern, err := getKernel("{{$key}}", "{{.RawName}}")
	if err != nil {
		return err
	}
	params := {{$argsName}}Args{
	{{range .GoArgs}}    {{.Name}}: {{.Name}},
	{{end}}
	}
	return kern.Launch(grid, block, {{passArgsPtrs .GoArgs "params"}})
}

func {{.Name}}Ex(grid, block cuda.Dim3, sharedMem uint64, stream *cuda.Stream, {{argPrint .GoArgs ", "}}) error {
	err := autoloadLib_{{$key}}()
	if err != nil {
		return err
	}
	kern, err := getKernel("{{$key}}", "{{.RawName}}")
	if err != nil {
		return err
	}
	params := {{$argsName}}Args{
	{{range .GoArgs}}    {{.Name}}: {{.Name}},
	{{end}}
	}
	return kern.LaunchEx(grid, block, sharedMem, stream, {{passArgsPtrs .GoArgs "params"}})
}
`
	prodAutoLoad autoloadTemplate = `{{$key := .GetKey }}
func autoloadLib_{{$key}}() error {
	if loaded_{{$key}} {
		return nil
	}
	err := InitLibrary([]byte({{.FileName | title}}_ptxCode), "{{$key}}")
	if err != nil {
		return err
	}
	loaded_{{$key}} = true
	return nil
}

const {{.FileName | title}}_ptxCode = ` + "`{{.PTXCode}}`"

	devAutoLoad autoloadTemplate = `{{$key := .GetKey }}
var pathToCompile_{{$key}} = "{{.Path}}"
func autoloadLib_{{$key}}() error {
	var code []byte
	if loaded_{{$key}} {
		return nil
	}
	code, err := compileFile(pathToCompile_{{$key}})
	if err != nil {
		return err
	}
	err = InitLibrary([]byte(code), "{{$key}}")
	if err != nil {
		return err
	}
	loaded_{{$key}} = true
	return nil
}
`
)

var templateFunctions = template.FuncMap{
	"upper":    strings.ToUpper,
	"lower":    strings.ToLower,
	"title":    func(s string) string { return string(unicode.ToUpper(rune(s[0]))) + s[1:] },
	"argPrint": argPrint,
	"passArgs": passArgs,
	"passArgsPtrs": func(args []Arg, from string) string {
		return passArgs(args, fmt.Sprintf("unsafe.Pointer(&%s.%%s)", from))
	},
	"namespaced": func(name, namespace string) string {
		return name + "_" + namespace
	},
}

func argPrint(args []Arg, sep string) string {
	var builder strings.Builder
	var i int = 0
	for _, gotype := range args {
		fmt.Fprintf(&builder, "%s %s", gotype.Name, gotype.Type)
		if i != len(args)-1 {
			builder.WriteString(sep)
		}
		i++
	}
	return builder.String()
}

func passArgs(args []Arg, pattern string) string {
	var builder strings.Builder
	var i int = 0
	for _, arg := range args {
		//fmt.Fprintf(&builder, pattern, name)
		builder.WriteString(passArg(arg.Name, pattern))
		if i != len(args)-1 {
			builder.WriteString(", ")
		}
		i++
	}
	return builder.String()
}

func passArg(name, pattern string) string {
	return fmt.Sprintf(pattern, name)
}
